<?php

/**
 * @file
 * supress_helper.module
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Installer\InstallerKernel;
use Drupal\Core\Site\Settings;
use Drupal\search_api\IndexInterface;

/**
 * Implements hook_cron().
 */
function supress_helper_cron() {
  /** @var \Drupal\Core\Queue\QueueFactory $queue_factory */
  $queue_factory = \Drupal::service('queue');
  $queue = $queue_factory->get('press_cover_downloader');

  $config_page_loader = \Drupal::service('config_pages.loader');
  $client_id = $config_page_loader->getValue('stanford_basic_site_settings', 'sup_filemaker_user', 0, 'value');
  $client_secret = $config_page_loader->getValue('stanford_basic_site_settings', 'sup_filemaker_pass', 0, 'value');

  if (
    !$client_id ||
    !$client_secret ||
    $queue->numberOfItems() > 0 ||
    InstallerKernel::installationAttempted()
  ) {
    return;
  }

  $client = \Drupal::httpClient();
  try {
    // Grab the OAuth-like token from the api.
    $token_response = $client->request('POST', 'https://memento.stanford.edu/fmi/data/v2/databases/Web/sessions', [
      'verify' => FALSE,
      'headers' => ['Content-Type' => 'application/json'],
      'auth' => [$client_id, $client_secret],
    ]);
    $token = json_decode((string) $token_response->getBody(), TRUE, 512, JSON_THROW_ON_ERROR);
    $token = $token['response']['token'];

    // Post a query to find the covers that are flagged to be updated. The API
    // is slow to respond so limiting to only 100 items will make it more
    // reliable.
    try {
      $covers_response = (string) $client->request('POST', 'https://memento.stanford.edu/fmi/data/v2/databases/Web/layouts/Covers/_find?_limit=100', [
        'verify' => FALSE,
        'headers' => [
          'Content-Type' => 'application/json',
          'Authorization' => 'Bearer ' . $token,
        ],
        'body' => json_encode(['query' => [['flag' => '=x']]]),
        'timeout' => 60,
      ])->getBody();
    }
    catch (\Exception $e) {
      // When there are no covers that match, the response is a 500 "error" even
      // though it should actually be a 204.
      return;
    }

    // Create a cron queue task for each cover.
    $covers = json_decode($covers_response, TRUE, 512, JSON_THROW_ON_ERROR);
    foreach ($covers['response']['data'] as $cover) {
      $queue->createItem($cover['recordId']);
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('supress_helper')
      ->error('Error in press cron job: ' . $e->getMessage());
  }
}

/**
 * Implements hook_search_api_algolia_objects_alter().
 */
function supress_helper_search_api_algolia_objects_alter(array &$objects, IndexInterface $index, array $items) {
  $term_storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
  foreach ($objects as &$object) {
    // Useful to limit record data for local algolia testing.
    if (Settings::get('algolia_limit_record')) {
      $object['html'] = implode(' ', array_slice(explode(' ', $object['html'] ?? ''), 0, 10));
    }

    if (isset($object['book_subject'])) {
      $object['book_subject'] = is_array($object['book_subject']) ? $object['book_subject'] : [$object['book_subject']];
      foreach ($object['book_subject'] as &$term_id) {
        while ($term_id) {
          $term = $term_storage->load($term_id);
          $term_id = $term->get('parent')->getString();

          if (!$term_storage->load($term_id)) {
            $term_id = FALSE;
          }
        }
        $term_id = $term->label();
      }
      asort($object['book_subject']);
      $object['book_subject'] = array_values(array_unique($object['book_subject']));
    }
  }
}

/**
 * Implements hook_field_widget_complete_WIDGET_TYPE_form_alter().
 */
function supress_helper_field_widget_complete_options_select_form_alter(&$field_widget_complete_form, FormStateInterface $form_state, $context) {
  if ($context['items']->getName() == 'sup_search_subject') {
    // Only show the top level terms and the "None" option.
    $field_widget_complete_form['widget']['#options'] = array_filter($field_widget_complete_form['widget']['#options'], fn($option) => !str_starts_with($option, '-') || $option == '- None -');
  }
}
